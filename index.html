<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pred Hold</title>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{margin:0;font-family:system-ui;background:#0b0f1f;color:#fff;padding:16px}
  h1{margin:0 0 12px;font-size:44px}
  .card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:14px}
  input{width:100%;padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);
        background:rgba(0,0,0,.25);color:#fff;font-size:16px}
  #status{margin-top:10px;opacity:.8;font-size:13px;line-height:1.35}

  .wrap{margin-top:12px;border:1px solid rgba(255,255,255,.10);border-radius:16px;
        overflow:auto;display:none;max-height:65vh;background:rgba(0,0,0,.18)}
  table{border-collapse:collapse;min-width:900px;width:100%}
  th,td{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);white-space:nowrap}
  th{font-size:12px;opacity:.7;text-align:left;position:sticky;top:0;background:#101427}
  .num{text-align:right;font-variant-numeric:tabular-nums}
  .player{white-space:normal;font-weight:800}
</style>
</head>
<body>
<h1>Pred Hold</h1>

<div class="card">
  <input id="file" type="file" accept=".csv,text/csv" />
  <div id="status">Upload your file.</div>

  <div id="wrap" class="wrap">
    <table>
      <thead>
        <tr>
          <th>Player</th>
          <th class="num">Odds</th>
          <th class="num">SPW%</th>
          <th class="num">RPW%</th>
          <th class="num">Pred Hold%</th>
        </tr>
      </thead>
      <tbody id="tb"></tbody>
    </table>
  </div>
</div>

<script>
const $=id=>document.getElementById(id);

const clamp=p=>Math.min(.999999,Math.max(.000001,p));
const n=v=>{
  v=(v??"").toString().trim();
  if(!v) return NaN;
  v=v.replace("%","").replace(",",".");
  const x=+v;
  return Number.isFinite(x)?x:NaN;
};

// Hold% from point win p (advantage game)
function holdFromPoint(p){
  p=clamp(p); const q=1-p;
  const pre=p**4*(1+4*q+10*q*q);
  const d=20*(p**3)*(q**3);
  const from=(p*p)/(1-2*p*q);
  return pre + d*from;
}

// predicted serve-point p = mean(SPW_A, 1 - RPW_B)
function pServe(spwA, rpwB){
  return clamp(((spwA/100) + ((100-rpwB)/100))/2);
}

const hk=s=>s.toString().trim().toLowerCase().replace(/%/g,"").replace(/[^a-z0-9]+/g,"");

async function parseFile(file){
  const parse = (delim)=>new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,delimiter:delim,complete:resolve,error:reject});
  });
  let r = await parse("");                  // auto
  if((r.meta?.fields||[]).length<=1) r = await parse("\t"); // TSV fallback
  return r;
}

$("file").addEventListener("change", async (e)=>{
  const file=e.target.files?.[0];
  if(!file) return;

  $("status").textContent="Parsingâ€¦";
  $("wrap").style.display="none";
  $("tb").innerHTML="";

  try{
    const res = await parseFile(file);
    const fields = res.meta?.fields || [];
    if(!fields.length){ $("status").textContent="No headers found."; return; }

    const map=new Map(fields.map(f=>[hk(f),f]));
    const kPlayer = map.get("player") || map.get("name");
    const kOdds   = map.get("odds") || map.get("price");
    const kSPW    = map.get("spw");
    const kRPW    = map.get("rpw");

    if(!kPlayer || !kSPW || !kRPW){
      $("status").textContent =
        `Missing columns. Need Player, SPW, RPW.\nFound headers: ${fields.join(" | ")}`;
      return;
    }

    // Clean rows
    const rows = (res.data||[]).map(r=>{
      const player=(r[kPlayer]??"").toString().trim();
      if(!player) return null;
      if(/^(surface|period|tour|match type|time)\s*:/i.test(player)) return null; // footer
      const spw=n(r[kSPW]), rpw=n(r[kRPW]);
      if(!Number.isFinite(spw) || !Number.isFinite(rpw)) return null;
      const odds = kOdds ? n(r[kOdds]) : NaN;
      return {player,odds,spw,rpw};
    }).filter(Boolean);

    if(rows.length < 2){
      $("status").textContent = `Loaded ${rows.length} rows. Need at least 2 (a couplet).`;
      return;
    }

    // Build output by couplets (A,B)
    const out = [];
    for(let i=0;i<rows.length-1;i+=2){
      const a = rows[i];
      const b = rows[i+1];

      const pA = pServe(a.spw, b.rpw);
      const pB = pServe(b.spw, a.rpw);

      out.push({...a, predHold: holdFromPoint(pA)*100});
      out.push({...b, predHold: holdFromPoint(pB)*100});
    }

    $("tb").innerHTML = out.map(r=>`
      <tr>
        <td class="player">${r.player}</td>
        <td class="num">${Number.isFinite(r.odds)?r.odds.toFixed(2):""}</td>
        <td class="num">${r.spw.toFixed(1)}</td>
        <td class="num">${r.rpw.toFixed(1)}</td>
        <td class="num">${r.predHold.toFixed(1)}</td>
      </tr>
    `).join("");

    $("wrap").style.display = "block";

    const dropped = rows.length % 2 === 1 ? 1 : 0;
    $("status").textContent =
      `Loaded ${rows.length} rows. Calculated Pred Hold for both players per couplet.` +
      (dropped ? ` (Dropped last orphan row.)` : ``);

  }catch(err){
    $("status").textContent = `Error: ${err?.message || err}`;
  }
});
</script>
</body>
</html>
