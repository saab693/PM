<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>PM Filter</title>

<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#6a00ff">
<link rel="icon" href="PM_icon.png">

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
:root{
  --bg:#090a12;
  --card:rgba(255,255,255,.06);
  --text:#f2f2f7;
  --muted:rgba(242,242,247,.72);
  --line:rgba(255,255,255,.10);
  --shadow:0 18px 60px rgba(0,0,0,.55);
  --radius:18px;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:
    radial-gradient(900px 500px at 20% -10%, rgba(106,0,255,.25), transparent 55%),
    radial-gradient(900px 500px at 90% 0%, rgba(106,0,255,.18), transparent 60%),
    var(--bg);
  color:var(--text);
  min-height:100vh;
  padding:18px 14px 28px;
}
.wrap{max-width:980px;margin:0 auto}

.header{
  display:flex;
  justify-content:space-between;
  align-items:flex-end;
  gap:12px;
  flex-wrap:wrap;
}
h1{margin:18px 0 14px;font-size:56px;font-weight:800;line-height:1}

.top-actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}

.panel{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:14px;
}

.row{display:grid;gap:12px;grid-template-columns:1fr}
@media(min-width:860px){
  .row.grid2{grid-template-columns:1fr 1fr}
}
.label{font-size:12px;color:var(--muted);margin-bottom:6px}

input,select{
  width:100%;
  background:rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.10);
  color:var(--text);
  border-radius:14px;
  padding:12px;
  font-size:16px;
}

.btn{
  width:100%;
  background:linear-gradient(180deg,#6a00ff,#5300c7);
  border:none;
  color:white;
  font-weight:900;
  padding:14px;
  border-radius:16px;
  font-size:18px;
  cursor:pointer;
}
.btn.secondary{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.12);
  color:rgba(242,242,247,.92);
  box-shadow:none;
}
.btn.small{
  width:auto;
  padding:10px 12px;
  font-size:14px;
  border-radius:12px;
}

.table-wrap{
  margin-top:14px;
  border-radius:var(--radius);
  border:1px solid var(--line);
  background:rgba(255,255,255,.04);
  overflow:hidden;
}
.scroller{overflow:auto}
table{border-collapse:separate;border-spacing:0;width:max-content;min-width:100%}
thead th{
  position:sticky;top:0;background:#10101a;border-bottom:1px solid var(--line);
  padding:12px;font-size:14px;white-space:nowrap
}
tbody td{padding:12px;border-bottom:1px solid rgba(255,255,255,.06);white-space:nowrap}
.player{font-weight:900;font-size:18px}
.muted{color:var(--muted);font-size:12px;margin-top:2px}

.pill{
  padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.08);
  cursor:pointer;font-weight:900; display:inline-block;
}
.pill.small{padding:7px 10px;font-size:13px}
.small{font-size:12px;color:var(--muted);margin-top:6px}
.right{text-align:right}

.match-row{background:rgba(255,255,255,.03); font-weight:900}
.match-title{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.match-actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

.toast{
  position:fixed;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  background:rgba(20,20,28,.92);
  border:1px solid rgba(255,255,255,.12);
  color:rgba(242,242,247,.95);
  padding:10px 12px;
  border-radius:12px;
  box-shadow:0 16px 50px rgba(0,0,0,.6);
  font-weight:900;
  opacity:0;
  pointer-events:none;
  transition:opacity .18s ease, transform .18s ease;
  z-index:9999;
}
.toast.show{opacity:1; transform:translateX(-50%) translateY(-2px);}
</style>
</head>

<body>
<div class="wrap">

  <div class="header">
    <h1>PM Filter</h1>
    <div class="top-actions">
      <button class="btn secondary small" id="exportToday">Export Today (0)</button>
      <button class="btn secondary small" id="copyToday">Copy Today</button>
      <button class="btn secondary small" id="clearToday">Clear</button>
    </div>
  </div>

  <div class="panel">

    <div class="row">
      <div>
        <div class="label">CSV file</div>
        <input id="file" type="file" accept=".csv,text/csv">
      </div>

      <div>
        <div class="label">Tour</div>
        <select id="tour">
          <option value="PRO">ATP / Challenger</option>
          <option value="WTA">WTA</option>
        </select>
      </div>

      <div>
        <div class="label">Predicted hold ≥ (SPW/RPW matchup)</div>
        <select id="holdMin"></select>
        <div class="small" id="holdHint"></div>
      </div>

      <div>
        <div class="label">Pred Combined ≥</div>
        <input id="minCombined" type="number" step="0.1" value="100">
      </div>

      <div class="row grid2">
        <button class="btn" id="run">Run Filter</button>
        <button class="btn secondary" id="export" disabled>Export Results (CSV)</button>
      </div>

      <div class="small">
        Rows are read in couplets. Odds ignored. If either player passes thresholds, both are shown.
      </div>
    </div>

    <div id="out" class="table-wrap" style="display:none">
      <div class="scroller">
        <table>
          <thead id="thead"></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>

  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ================== stable core ================== */
const HOLD_PRESETS = {
  PRO: { values:[75,76,77,78,79,80,81,82,83,84,85], def:78, label:"ATP/Challenger preset" },
  WTA: { values:[63,64,65,66,67,68,69,70,71,72,73,74,75], def:66, label:"WTA preset" }
};

const fileEl=document.getElementById("file");
const tourEl=document.getElementById("tour");
const holdMinEl=document.getElementById("holdMin");
const holdHintEl=document.getElementById("holdHint");
const minCombinedEl=document.getElementById("minCombined");
const exportBtn=document.getElementById("export");
const toast=document.getElementById("toast");

let LAST_RENDERED_MATCHES = [];

let toastTimer=null;
function showToast(msg){
  toast.textContent=msg;
  toast.classList.add("show");
  clearTimeout(toastTimer);
  toastTimer=setTimeout(()=>toast.classList.remove("show"), 900);
}

function rebuildHoldDropdown(){
  const preset=HOLD_PRESETS[tourEl.value];
  holdMinEl.innerHTML="";
  preset.values.forEach(v=>{
    const opt=document.createElement("option");
    opt.value=v;
    opt.textContent=v+"%";
    holdMinEl.appendChild(opt);
  });
  holdMinEl.value=preset.def;
  holdHintEl.textContent=preset.label;
}
tourEl.addEventListener("change",rebuildHoldDropdown);
rebuildHoldDropdown();

function num(x){
  return parseFloat(String(x??"").replace("%","").replace(",",".").trim());
}
const pctToDec = p => p/100;
const decToPct = d => d*100;

function holdFromPointP(p){
  if(!(p>0 && p<1)) return NaN;
  const q = 1 - p;
  const first = Math.pow(p,4) * (1 + 4*q + 10*q*q);
  const deuceReach = 20 * Math.pow(p,3) * Math.pow(q,3);
  const pWinFromDeuce = (p*p) / (1 - 2*p*q);
  return first + deuceReach * pWinFromDeuce;
}
function matchupPointServe(spwA_dec, rpwB_dec){
  return (spwA_dec + (1 - rpwB_dec)) / 2;
}
function pick(row, names){
  for(const n of names){
    if(row[n] !== undefined) return row[n];
  }
  return undefined;
}
function extract(row){
  const player = pick(row, ["Player","player","Name","name"]);
  const spw  = pick(row, ["SPW %","SPW%","SPW"]);
  const rpw  = pick(row, ["RPW %","RPW%","RPW"]);
  const sh   = pick(row, ["SH %","SH%","Hold","Hold%","Hold %"]);
  const oph  = pick(row, ["OpH %","OpH%","Opponent Hold","Opponent Hold %","Opp Hold %"]);
  return {
    player: String(player??"").trim(),
    spw: num(spw),
    rpw: num(rpw),
    sh: num(sh),
    oph: num(oph)
  };
}

function computeFallback(x, opp){
  const hold = Number.isFinite(x.sh) ? x.sh : NaN;

  let oppHold = NaN;
  if(opp && Number.isFinite(opp.sh)) oppHold = opp.sh;
  else if(Number.isFinite(x.oph)) oppHold = x.oph;

  const brk = Number.isFinite(oppHold) ? 100 - oppHold : NaN;
  const comb = (Number.isFinite(hold) && Number.isFinite(brk)) ? hold + brk : NaN;

  return { ...x, opponent: opp ? opp.player : "", predHold: hold, predBreak: brk, predCombined: comb };
}

function computeMatchup(a,b){
  const usable = Number.isFinite(a.spw) && Number.isFinite(a.rpw) && Number.isFinite(b.spw) && Number.isFinite(b.rpw);
  if(usable){
    const pServeA = matchupPointServe(pctToDec(a.spw), pctToDec(b.rpw));
    const pServeB = matchupPointServe(pctToDec(b.spw), pctToDec(a.rpw));
    const holdA = decToPct(holdFromPointP(pServeA));
    const holdB = decToPct(holdFromPointP(pServeB));
    const breakA = 100 - holdB;
    const breakB = 100 - holdA;
    return {
      a: { ...a, opponent: b.player, predHold: holdA, predBreak: breakA, predCombined: holdA + breakA },
      b: { ...b, opponent: a.player, predHold: holdB, predBreak: breakB, predCombined: holdB + breakB }
    };
  }
  return { a: computeFallback(a,b), b: computeFallback(b,a) };
}

function buildMatches(parsedRows){
  const rows = parsedRows.map(extract);
  const matches = [];
  for(let i=0;i<rows.length;i+=2){
    const a = rows[i];
    const b = rows[i+1];
    if(!a || !a.player) continue;
    if(!b || !b.player){
      matches.push({ a: computeFallback(a), b: null, idx: i });
      continue;
    }
    const computed = computeMatchup(a,b);
    matches.push({ ...computed, idx: i });
  }
  return matches;
}

function matchPasses(m){
  const holdMin = num(holdMinEl.value);
  const minComb = num(minCombinedEl.value);
  const passSide = (s)=>{
    if(!s) return false;
    if(!Number.isFinite(s.predHold) || !Number.isFinite(s.predCombined)) return false;
    return s.predHold >= holdMin && s.predCombined >= minComb;
  };
  return passSide(m.a) || passSide(m.b);
}

function escapeHtml(s){
  return String(s??"")
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

async function copyText(text){
  try{ await navigator.clipboard.writeText(text); showToast("Copied"); }
  catch(e){ showToast("Copy failed"); }
}

/* ================== Today export (minimal, no UI list) ================== */
/* Everything in try/catch so even if something goes wrong, core app still runs. */
const LS_KEY = "pm_today_minimal_v1";
let TODAY = [];
try{
  const raw = localStorage.getItem(LS_KEY);
  TODAY = raw ? JSON.parse(raw) : [];
  if(!Array.isArray(TODAY)) TODAY = [];
}catch(e){
  TODAY = [];
}

const exportTodayBtn = document.getElementById("exportToday");
const copyTodayBtn = document.getElementById("copyToday");
const clearTodayBtn = document.getElementById("clearToday");

function saveToday(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(TODAY)); }catch(e){}
  exportTodayBtn.textContent = `Export Today (${TODAY.length})`;
}
saveToday();

function keyForMatch(m){
  const p1 = m.a?.player || "";
  const p2 = m.b?.player || "";
  return (p1 && p2 ? [p1,p2].sort().join("___") : p1).toLowerCase();
}
function titleForMatch(m){
  return m.b ? `${m.a.player} vs ${m.b.player}` : `${m.a.player}`;
}
function simplifySide(s){
  if(!s) return null;
  return {
    player: s.player,
    opponent: s.opponent || "",
    predHold: Number.isFinite(s.predHold) ? +s.predHold.toFixed(1) : null,
    predBreak: Number.isFinite(s.predBreak) ? +s.predBreak.toFixed(1) : null,
    predCombined: Number.isFinite(s.predCombined) ? +s.predCombined.toFixed(1) : null,
    spw: Number.isFinite(s.spw) ? +s.spw.toFixed(1) : null,
    rpw: Number.isFinite(s.rpw) ? +s.rpw.toFixed(1) : null
  };
}

function addToToday(m){
  const key = keyForMatch(m);
  if(TODAY.some(x => x.key === key)){
    showToast("Already added");
    return;
  }
  TODAY.unshift({
    key,
    title: titleForMatch(m),
    tour: tourEl.value === "WTA" ? "WTA" : "ATP/CH",
    addedAt: new Date().toISOString(),
    a: simplifySide(m.a),
    b: simplifySide(m.b)
  });
  saveToday();
  showToast("Added");
}

function clearToday(){
  TODAY = [];
  saveToday();
  showToast("Cleared");
}

function downloadCSV(rows, filename){
  if(!rows.length){ showToast("Nothing to export"); return; }
  const headers = Object.keys(rows[0]);
  const escapeCell = (v)=>{
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const lines = [];
  lines.push(headers.map(escapeCell).join(","));
  rows.forEach(r=>{
    lines.push(headers.map(h=>escapeCell(r[h])).join(","));
  });
  const csv = lines.join("\n");
  const blob = new Blob([csv], { type:"text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function exportTodayCSV(){
  if(!TODAY.length){ showToast("Today is empty"); return; }
  const rows = [];
  TODAY.forEach(item=>{
    const matchName = item.title;
    [item.a, item.b].forEach(s=>{
      if(!s) return;
      rows.push({
        Match: matchName,
        Tour: item.tour,
        Player: s.player,
        Opponent: s.opponent || "",
        "Pred Hold": s.predHold ?? "",
        "Pred Break": s.predBreak ?? "",
        "Pred Combined": s.predCombined ?? "",
        "SPW %": s.spw ?? "",
        "RPW %": s.rpw ?? "",
        AddedAt: item.addedAt
      });
    });
  });
  const stamp = new Date().toISOString().slice(0,10).replace(/-/g,"");
  downloadCSV(rows, `PM_today_${stamp}.csv`);
}

function copyToday(){
  if(!TODAY.length){ showToast("Today is empty"); return; }
  const lines = TODAY.map(x => x.title);
  copyText(lines.join("\n"));
}

exportTodayBtn.addEventListener("click", exportTodayCSV);
copyTodayBtn.addEventListener("click", copyToday);
clearTodayBtn.addEventListener("click", clearToday);

/* ================== render results ================== */
function render(matches){
  const thead=document.getElementById("thead");
  const tbody=document.getElementById("tbody");

  thead.innerHTML = `
    <tr>
      <th>Match</th>
      <th></th>
      <th class="right">Pred Hold</th>
      <th class="right">Pred Break</th>
      <th class="right">Pred Combined</th>
      <th class="right">SPW</th>
      <th class="right">RPW</th>
    </tr>`;
  tbody.innerHTML="";

  matches.forEach((m, idx)=>{
    const title = titleForMatch(m);
    const key = keyForMatch(m);
    const already = TODAY.some(x => x.key === key);

    const trH = document.createElement("tr");
    trH.className = "match-row";
    trH.innerHTML = `
      <td colspan="7">
        <div class="match-title">
          <span>${escapeHtml(title)}</span>
          <span class="match-actions">
            <span class="pill small" data-add="${idx}" style="${already ? "opacity:.55" : ""}">
              ${already ? "Added ✓" : "Add"}
            </span>
            <span class="pill small" data-copytitle="${encodeURIComponent(title)}">⚡ Copy</span>
          </span>
        </div>
      </td>`;
    tbody.appendChild(trH);

    [m.a, m.b].forEach(s=>{
      if(!s) return;
      const tr=document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div class="player">${escapeHtml(s.player)}</div>
          ${s.opponent ? `<div class="muted">vs ${escapeHtml(s.opponent)}</div>` : ``}
        </td>
        <td><span class="pill" data-copy="${encodeURIComponent(s.player)}">⚡</span></td>
        <td class="right">${Number.isFinite(s.predHold) ? s.predHold.toFixed(1) : ""}</td>
        <td class="right">${Number.isFinite(s.predBreak) ? s.predBreak.toFixed(1) : ""}</td>
        <td class="right">${Number.isFinite(s.predCombined) ? s.predCombined.toFixed(1) : ""}</td>
        <td class="right">${Number.isFinite(s.spw) ? s.spw.toFixed(1) : ""}</td>
        <td class="right">${Number.isFinite(s.rpw) ? s.rpw.toFixed(1) : ""}</td>
      `;
      tbody.appendChild(tr);
    });
  });

  tbody.querySelectorAll("[data-copy]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const name = decodeURIComponent(el.getAttribute("data-copy") || "");
      copyText(name);
    });
  });

  tbody.querySelectorAll("[data-copytitle]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const t = decodeURIComponent(el.getAttribute("data-copytitle") || "");
      copyText(t);
    });
  });

  tbody.querySelectorAll("[data-add]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const i = parseInt(el.getAttribute("data-add"), 10);
      if(Number.isFinite(i) && LAST_RENDERED_MATCHES[i]){
        addToToday(LAST_RENDERED_MATCHES[i]);
        // visual feedback
        el.textContent = "Added ✓";
        el.style.opacity = ".55";
      }
    });
  });

  document.getElementById("out").style.display="block";
}

/* ================== export results ================== */
function toExportRows(matches){
  const rows = [];
  matches.forEach(m=>{
    const matchName = titleForMatch(m);
    [m.a, m.b].forEach(s=>{
      if(!s) return;
      rows.push({
        Match: matchName,
        Player: s.player,
        Opponent: s.opponent || "",
        "Pred Hold": Number.isFinite(s.predHold) ? s.predHold.toFixed(1) : "",
        "Pred Break": Number.isFinite(s.predBreak) ? s.predBreak.toFixed(1) : "",
        "Pred Combined": Number.isFinite(s.predCombined) ? s.predCombined.toFixed(1) : "",
        "SPW %": Number.isFinite(s.spw) ? s.spw.toFixed(1) : "",
        "RPW %": Number.isFinite(s.rpw) ? s.rpw.toFixed(1) : ""
      });
    });
  });
  return rows;
}

document.getElementById("export").addEventListener("click", ()=>{
  if(!LAST_RENDERED_MATCHES.length){ showToast("Run filter first"); return; }
  const tour = tourEl.value === "WTA" ? "WTA" : "ATP_CH";
  const holdMin = holdMinEl.value;
  const comb = minCombinedEl.value;
  const stamp = new Date().toISOString().slice(0,10).replace(/-/g,"");
  downloadCSV(toExportRows(LAST_RENDERED_MATCHES), `PM_results_${tour}_H${holdMin}_C${comb}_${stamp}.csv`);
});

/* ================== run ================== */
document.getElementById("run").onclick=()=>{
  const f = fileEl.files && fileEl.files[0];
  if(!f){ showToast("Choose a CSV"); return; }

  Papa.parse(f,{
    header:true,
    skipEmptyLines:true,
    complete:(res)=>{
      const matches = buildMatches(res.data || []);
      const filteredMatches = matches.filter(matchPasses);

      LAST_RENDERED_MATCHES = filteredMatches;
      exportBtn.disabled = filteredMatches.length === 0;

      render(filteredMatches);
      showToast(filteredMatches.length ? "Done" : "No matches");
    },
    error: ()=>{
      showToast("Parse failed");
    }
  });
};

// keep PWA installable
if ("serviceWorker" in navigator){
  window.addEventListener("load", ()=>{
    navigator.serviceWorker.register("./sw.js").catch(()=>{});
  });
}
</script>
</body>
</html>
